{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport namor from 'namor';\nexport const isEmpty = value => {\n  return value === null || value === undefined || typeof value === 'object' && Object.keys(value).length === 0 || typeof value === 'string' && value.trim().length === 0;\n};\n\nconst range = len => {\n  const arr = [];\n\n  for (let i = 0; i < len; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n};\n\nfunction newPerson() {\n  const statusChance = Math.random();\n  const firstName = namor.generate({\n    words: 1,\n    numbers: 0\n  });\n  const lastName = namor.generate({\n    words: 1,\n    numbers: 0\n  });\n  return {\n    firstName,\n    lastName,\n    email: firstName + lastName + '@gmail.com',\n    inviteSent: Math.floor(Math.random() * 100) % 2 ? 'Yes' : 'No',\n    testSent: Math.floor(Math.random() * 30) % 2 ? 'Yes' : 'No',\n    testStatus: statusChance > 0.66 ? 'pending' : statusChance > 0.33 ? 'sent' : 'received'\n  };\n}\n\nexport default function makeData(...lens) {\n  const makeDataLevel = (depth = 0) => {\n    const len = lens[depth];\n    return range(len).map(_ => {\n      return _objectSpread(_objectSpread({}, newPerson()), {}, {\n        subRows: lens[depth + 1] ? makeDataLevel(depth + 1) : undefined\n      });\n    });\n  };\n\n  return makeDataLevel();\n}\nexport const getFileSizeAndUnit = size => {\n  const fSExt = ['Bytes', 'KB', 'MB', 'GB'];\n  let i = 0;\n  let _size = size;\n\n  while (_size > 900) {\n    _size /= 1024;\n    i++;\n  }\n\n  const exactSize = Math.round(_size * 100) / 100 + ' ' + fSExt[i];\n  return exactSize;\n};\nexport function copyToClipboard(text) {\n  const input = document.createElement('input');\n  input.setAttribute('value', text);\n  document.body.appendChild(input);\n  input.select();\n  const result = document.execCommand('copy');\n  document.body.removeChild(input);\n  return result;\n}\nexport const properCase = str => {\n  if (str && typeof str === 'string' && str.trim().length === 1) {\n    return String(str).trim().toUpperCase();\n  }\n\n  if (str && typeof str === 'string') {\n    return str.trim().split(' ').map(w => w[0] && w[0].toUpperCase() + w.substr(1).toLowerCase()).join(' ');\n  }\n\n  return str;\n};","map":null,"metadata":{},"sourceType":"module"}